/*******************************************************************************
License:
This software was developed at the National Institute of Standards and
Technology (NIST) by employees of the Federal Government in the course
of their official duties. Pursuant to title 17 Section 105 of the
United States Code, this software is not subject to copyright protection
and is in the public domain. NIST assumes no responsibility  whatsoever for
its use by other parties, and makes no guarantees, expressed or implied,
about its quality, reliability, or any other characteristic.

This software has been determined to be outside the scope of the EAR
(see Part 734.3 of the EAR for exact details) as it has been created solely
by employees of the U.S. Government; it is freely distributed with no
licensing requirements; and it is considered public domain. Therefore,
it is permissible to distribute this software as a free download from the
internet.

Disclaimer:
This software was developed to promote biometric standards and biometric
technology testing for the Federal Government in accordance with the USA
PATRIOT Act and the Enhanced Border Security and Visa Entry Reform Act.
Specific hardware and software products identified in this software were used
in order to perform the software development.  In no case does such
identification imply recommendation or endorsement by the National Institute
of Standards and Technology, nor does it imply that the products and equipment
identified are necessarily the best available for the purpose.
*******************************************************************************/
// #include "exceptions.h"
#include "filter_mask_gaussian.h"
#include "filter_mask_ideal.h"
#include "nfimm.h"
#include "nfir_lib.h"
#include "resample_down.h"
#include "resample_up.h"

#include <opencv2/opencv.hpp>

/** Library private methods declarations */
static std::string getImageDepthStr( const int );
static cv::Mat padImage( cv::Mat, Padding& );
static void validateUserSpecifiedSampleRates( int, int );


namespace NFIR {

/** @brief W x H of filteredImgPriorToDownsample */
uint32_t *filteredImgPriorToDownsampleDimens;

/**
 * @brief Filtered source-image prior to downsample by *resize factor*.
 * 
 * This image is space-domain, png format. Was generated by the inverse DFT
 * of the frequency domain product of:
 *  - the padded image
 *  - the lowpass filter
 * 
 * This "intermediate" image has been cropped of its zero-padding.
 * 
 * The 1D-frequency power spectrum signal for this image proves that the
 * lowpass filter has been applied. Therefore, downsampling (of this image)
 * will not introduce aliasing where high spacial frequencies appear
 * as low spacial frequencies.
 */
cv::Mat filteredImgPriorToDownsample;

/**
 * @param srcImage IN pointer to source image
 * @param tgtImage OUT pointer to generated, target image
 * @param srcSampleRate value must reflect srUnits
 * @param tgtSampleRate value must reflect srUnits
 * @param srUnits sample rate [ inch | meter | other ]
 * @param interpolationMethod [ bilinear | bicubic ]
 * @param filterShape [ ideal | Gaussian ]
 * @param imageWidth  IN -  width of source image,
                      OUT - width of generated, target image
 * @param imageHeight IN -  height of source image,
 *                    OUT - height of generated, target image
 * @param imgBufSize  IN -  length of the source image buffer
 *                    OUT - length of the generated, target image buffer
 * @param srcComp compression format of source image
 * @param tgtComp compression format of target image
 * @param log resample-process metadata for reporting to caller
 *
 * @throw NFIR::Miscue for invalid sample rate(s), interpolation method,
 *              downsample filter shape, or cannot resize image
 */
void
resample( uint8_t *srcImage, uint8_t **tgtImage,
          int srcSampleRate, int tgtSampleRate, const std::string &srUnits,
          const std::string &interpolationMethod, const std::string &filterShape,
          uint32_t *imageWidth, uint32_t *imageHeight,
          size_t *imgBufSize,
          const std::string &srcComp, const std::string &tgtComp,
          std::vector<std::string> &vecPngTextChunk,
          std::vector<std::string> &log
        )
{
  std::vector<uint8_t> vecSrcImg;
  // Copy the srcImage into vector for decoding
  for( size_t i=0; i<*imgBufSize; i++ ) {
    vecSrcImg.push_back( srcImage[i] );
  }

  cv::Mat srcImageMtx;
  cv::Mat tmpImageMtx = cv::imdecode( cv::Mat(vecSrcImg), cv::IMREAD_UNCHANGED );
  log.push_back( "SRC img std::vector size: " + std::to_string(vecSrcImg.size()) );
  log.push_back( "SRC img cv::matrix size: "
                + std::to_string(tmpImageMtx.total()) );
  log.push_back( "SRC img WxH: "
                + std::to_string(tmpImageMtx.cols) + "x"
                + std::to_string(tmpImageMtx.rows) );
  log.push_back( "SRC img bit depth: " + getImageDepthStr(tmpImageMtx.depth()) );
  log.push_back( "SRC img num channels: " + std::to_string(tmpImageMtx.channels()) );


  cv::Mat tgtImageMatrix{};
  tgtImageMatrix.release();

  if( tmpImageMtx.channels() > 1 )
  {
    cv::cvtColor( tmpImageMtx, srcImageMtx, cv::COLOR_BGR2GRAY );
    log.push_back( "SRC IMG converted to single-channel: TRUE" );
  }
  else if( tmpImageMtx.channels() == 1 )
  {
    srcImageMtx = tmpImageMtx.clone();
    log.push_back( "SRC IMG converted to single-channel: FALSE" );
  }
  else
  {
    throw NFIR::Miscue( "NFIR lib: SRC IMG num channels not supported" );
  }
  tmpImageMtx.release();


  // int errCode{0};
  try
  {
    validateUserSpecifiedSampleRates( srcSampleRate, tgtSampleRate );
  }
  catch( const NFIR::Miscue &e ) {
    throw e;
  }

  cv::Mat paddedImg;
  Padding actualPadSize;
  uint8_t *tgtImageResampled;
  std::vector<uint8_t> vecTgtImage, vecTgtImageNFIMM;
  std::string encComp{"."};
  std::vector<std::string> resample_metadata;

  // Declare the pointers to metadata params and metadata modifier objects.
  // NFIMM is the base class for PNG and BMP derived classes.
  std::shared_ptr<NFIMM::MetadataParameters> mp;
  std::unique_ptr<NFIMM::NFIMM> nfimm_mp;


  // Based on UP or DOWN sample, instantiate the proper object.
  if( tgtSampleRate > srcSampleRate )   // Upsample
  {
    std::unique_ptr<Upsample> resampler(new Upsample( srcSampleRate, tgtSampleRate ));
    resampler->set_interpolationMethod( interpolationMethod );

    resample_metadata.clear();
    resample_metadata = resampler->to_s();
    for( auto s : resample_metadata ) { log.push_back(s); }

    try {
      tgtImageMatrix = resampler->resize( srcImageMtx );
    }
    catch( const cv::Exception& ex ) {
      std::string err{"NFIR lib: Upsample failed resize(): "};
      err.append( ex.what() );
      throw NFIR::Miscue( err );
    }

    if( tgtImageMatrix.empty() ) {
      throw NFIR::Miscue( "NFIR lib: Upsample failed resized target == 0" );
    }

    // Save dims to OUT pointers
    *imageWidth = tgtImageMatrix.cols;
    *imageHeight = tgtImageMatrix.rows;
    log.push_back( "UPSAMPLE target img WxH: " + std::to_string(tgtImageMatrix.cols) + "x" + std::to_string(tgtImageMatrix.rows) );
    log.push_back( "UPSAMPLE target img matrix size: " + std::to_string(tgtImageMatrix.total()) );

    // Encode image to stream of bytes.
    std::string ncSrcComp = srcComp;  // nc = non-const; for tolower() below
    std::transform( ncSrcComp.begin(), ncSrcComp.end(),
                    ncSrcComp.begin(), ::tolower );
    encComp.append( srcComp );
    cv::imencode( encComp, tgtImageMatrix, vecTgtImage );
    // Copy the vector to an array of bytes(uint8_t) for call to NFIMM.

    log.push_back( "UPSAMPLE target img vector size: "
                  + std::to_string(vecTgtImage.size()) );
    log.push_back( "UPSAMPLE target img matrix size: "
                  + std::to_string(tgtImageMatrix.total()) );
    log.push_back( "UPSAMPLE target img WxH: "
                  + std::to_string(tgtImageMatrix.cols) + "x"
                  + std::to_string(tgtImageMatrix.rows) );
    log.push_back( "UPSAMPLE target img num channels: "
                  + std::to_string(tgtImageMatrix.channels()) );

    if( ncSrcComp == "png" || ncSrcComp == "bmp" )
    {
      try
      {
        // NFIMM (NIST Fingerprint Image Metadata Modifier library)
        // START Create the metadata
        mp.reset( new NFIMM::MetadataParameters( ncSrcComp ) );
        mp->srcImg.resolution.horiz = srcSampleRate;
        mp->srcImg.resolution.vert = srcSampleRate;
        mp->set_srcImgSampleRateUnits( srUnits );
        mp->destImg.resolution.horiz = tgtSampleRate;
        mp->destImg.resolution.vert = tgtSampleRate;
        mp->set_destImgSampleRateUnits( srUnits );
        mp->destImg.textChunk = vecPngTextChunk;
        // END Create the metadata

        if( ncSrcComp == "bmp" )
          nfimm_mp.reset( new NFIMM::BMP( mp ) );
        else
          nfimm_mp.reset( new NFIMM::PNG( mp ) );

        nfimm_mp->readImageFileIntoBuffer( vecTgtImage );
        nfimm_mp->modify();
        nfimm_mp->retrieveWriteImageBuffer( vecTgtImageNFIMM );
        // Push the NFIMM logging data to the NFIR log
        log.push_back( mp->to_s() );
        for( std::string s : mp->log ) { log.push_back( s ); }
        // mp->log.clear();
      }
      catch( const NFIMM::Miscue &err ) {
        log.push_back( "NFIMM modify() failed, log prior to exception below:" );
        log.push_back( mp->to_s() );
        throw NFIR::Miscue( err.what() );
      }

      // copy the image buffer to be written to disk from NFIMM object
      uint64 tgtImgSize{vecTgtImageNFIMM.size()};
      tgtImageResampled = new uint8_t[tgtImgSize];
      for( size_t i=0; i<tgtImgSize; i++ ) {
        tgtImageResampled[i] = vecTgtImageNFIMM[i];
      }
      *tgtImage = tgtImageResampled;
      *imgBufSize = tgtImgSize;
    }
    else
    {
      // copy the image buffer to be written to disk from NFIR object
      tgtImageResampled = new uint8_t[vecTgtImage.size()];
      for( size_t i=0; i<vecTgtImage.size(); i++ ) {
        tgtImageResampled[i] = vecTgtImage.at(i);
      }
      // Update the function parameter for caller to use to write image.
      *tgtImage = tgtImageResampled;
      *imgBufSize = vecTgtImage.size();
    }
    return;
  }

  // Not an UPSAMPLE, so start the DOWNSAMPLE process.
  FilterMask *currentFilter;
  // std::unique_ptr<FilterMask> currentFilter; 
  paddedImg = padImage( srcImageMtx, actualPadSize );
  log.push_back( actualPadSize.to_s() );

  // Build the filter/mask for freq domain mulSpectums.
  // The filter/mask is same dimension (WxH) as the padded, source image.
  try
  {
    // auto resampler = new Downsample( srcSampleRate, tgtSampleRate );
    std::unique_ptr<Downsample> resampler( new Downsample( srcSampleRate, tgtSampleRate ) );
    resampler->set_interpolationMethodAndFilterShape( interpolationMethod,
                                                      filterShape );
    if( resampler->get_filterShape() == "Gaussian" )
    {
      currentFilter = new Gaussian( srcSampleRate, tgtSampleRate );
      // currentFilter.reset( new Gaussian( srcSampleRate, tgtSampleRate ));
      currentFilter->build( paddedImg.size() );
    }
    else if( resampler->get_filterShape() == "ideal" )
    {
      currentFilter = new Ideal( srcSampleRate, tgtSampleRate );
      // currentFilter.reset( new Ideal( srcSampleRate, tgtSampleRate ));
      currentFilter->build( paddedImg.size() );
    }
    else
    {
      throw NFIR::Miscue( "NFIR lib: invalid parameter filter shape: '"
                         + resampler->get_filterShape() + "'");
    }

    // Now that the padded, source image and current filter/mask are available,
    // ready to downsample.
    resample_metadata.clear();
    log.push_back( ">> START DOWNSAMPLE (resampler) metadata:" );
    resample_metadata = resampler->to_s();
    for( auto s : resample_metadata ) { log.push_back(s); }
    log.push_back( ">> END DOWNSAMPLE (resampler) metadata" );

    tgtImageMatrix = resampler->resize( paddedImg, currentFilter, actualPadSize );
    if( tgtImageMatrix.empty() ) {
      throw NFIR::Miscue( "NFIR lib: Downsample failed resize(), target image empty" );
    }

    NFIR::filteredImgPriorToDownsampleDimens = resampler->get_filteredImageDimens();
    NFIR::filteredImgPriorToDownsample = resampler->get_filteredImage();
    log.push_back( "LOW-PASS-FILTERED target image PRIOR to decimation - WxH: "
                  + std::to_string(NFIR::filteredImgPriorToDownsampleDimens[0]) + "x"
                  + std::to_string(NFIR::filteredImgPriorToDownsampleDimens[1]) );

    // Save dims to OUT pointers
    *imageWidth = tgtImageMatrix.cols;
    *imageHeight = tgtImageMatrix.rows;

    std::string ncSrcComp = srcComp;  // nc = non-const; for tolower() below
    std::transform( ncSrcComp.begin(), ncSrcComp.end(),
                    ncSrcComp.begin(), ::tolower );
    encComp.append( srcComp );
    cv::imencode( encComp, tgtImageMatrix, vecTgtImage );

    log.push_back( "DOWNSAMPLE target img vector size: "
                  + std::to_string(vecTgtImage.size()) );
    log.push_back( "DOWNSAMPLE target img matrix size: "
                  + std::to_string(tgtImageMatrix.total()) );
    log.push_back( "DOWNSAMPLE target img WxH: "
                  + std::to_string(tgtImageMatrix.cols) + "x"
                  + std::to_string(tgtImageMatrix.rows) );
    log.push_back( "DOWNSAMPLE target img num channels: "
                  + std::to_string(tgtImageMatrix.channels()) );

    if( ncSrcComp == "png" || ncSrcComp == "bmp" )
    {
      try
      {
        // NFIMM (NIST Fingerprint Image Metadata Modifier library)
        // START Create the metadata
        mp.reset( new NFIMM::MetadataParameters( ncSrcComp ) );
        mp->srcImg.resolution.horiz = srcSampleRate;
        mp->srcImg.resolution.vert = srcSampleRate;
        mp->set_srcImgSampleRateUnits( srUnits );
        mp->destImg.resolution.horiz = tgtSampleRate;
        mp->destImg.resolution.vert = tgtSampleRate;
        mp->set_destImgSampleRateUnits( srUnits );
        mp->destImg.textChunk = vecPngTextChunk;
        // END Create the metadata

        if( ncSrcComp == "bmp" )
          nfimm_mp.reset( new NFIMM::BMP( mp ) );
        else
          nfimm_mp.reset( new NFIMM::PNG( mp ) );

        nfimm_mp->readImageFileIntoBuffer( vecTgtImage );
        nfimm_mp->modify();
        nfimm_mp->retrieveWriteImageBuffer( vecTgtImageNFIMM );
        // Push the NFIMM logging data to the NFIR log
        log.push_back( mp->to_s() );
        for( std::string s : mp->log ) { log.push_back( s ); }
        // mp->log.clear();
      }
      catch( const NFIMM::Miscue &err ) {
        log.push_back( "NFIMM modify() failed, log prior to exception below:" );
        log.push_back( mp->to_s() );
        throw NFIR::Miscue( err.what() );
      }

      // copy the image buffer to be written to disk from NFIMM object
      uint64 tgtImgSize{vecTgtImageNFIMM.size()};
      tgtImageResampled = new uint8_t[tgtImgSize];
      for( size_t i=0; i<tgtImgSize; i++ ) {
        tgtImageResampled[i] = vecTgtImageNFIMM[i];
      }
      *tgtImage = tgtImageResampled;
      *imgBufSize = tgtImgSize;
    }
    else
    {
      // copy the image buffer to be written to disk from NFIR object
      tgtImageResampled = new uint8_t[vecTgtImage.size()];
      for( size_t i=0; i<vecTgtImage.size(); i++ ) {
        tgtImageResampled[i] = vecTgtImage.at(i);
      }
      // Update the function parameter for caller to use to write image.
      *tgtImage = tgtImageResampled;
      *imgBufSize = vecTgtImage.size();
    }

    // Clean up
    delete currentFilter;
    currentFilter = nullptr;
  }
  catch( const cv::Exception& ex ) {
    std::string err{"NFIR lib: Downsample failed resize(): "};
    err.append( ex.what() );
    throw NFIR::Miscue( err );
  }
  return;
}


std::string
printVersion()
{
  std::string s{ "NFIR (NIST Fingerprint Image Resampler) version: " };
  s.append( NFIR_VERSION );
  s.append( "\nNIST Fingerprint Image Metadata Modifier version: "
            + NFIMM::printVersion() );
  s.append( "\nOpenCV version: ");
  s.append(CV_VERSION);
  return s;
}

std::string
getVersion()
{
  return NFIR_VERSION;
}

void get_filteredImage( uint8_t** filteredImage,
                        const std::string &encodeCompression,
                        size_t   *imgBufSize,
                        uint32_t *imageWidth,
                        uint32_t *imageHeight )
{
  std::vector<uint8_t> vecFilteredImage;
  uint8_t *filteredImageTmp;

  std::string encCompLocal{"."};
  encCompLocal.append( encodeCompression );

  *imageWidth  = filteredImgPriorToDownsampleDimens[0];
  *imageHeight = filteredImgPriorToDownsampleDimens[1];

  cv::imencode( encCompLocal, filteredImgPriorToDownsample, vecFilteredImage );
  *imgBufSize = vecFilteredImage.size();

  filteredImageTmp = new uint8_t[vecFilteredImage.size()];
  for( size_t i=0; i<vecFilteredImage.size(); i++ ) {
    filteredImageTmp[i] = vecFilteredImage.at(i);
  }
  *filteredImage = filteredImageTmp;
}

}   // End namespace


/**
 * @brief Decode the OpenCV enum.
 *
 * A Mapping of Type to Numbers in OpenCV:\n
 *        C1  C2  C3  C4\n
 * CV_8U   0   8  16  24\n
 * CV_8S   1   9  17  25\n
 * CV_16U  2  10  18  26\n
 * CV_16S  3  11  19  27\n
 * CV_32S  4  12  20  28\n
 * CV_32F  5  13  21  29\n
 * CV_64F  6  14  22  30
 *
 * @param depth of image
 *
 * @return description of bit-depth
 */
std::string getImageDepthStr( const int depth )
{
  std::string img_depth_str{"invalid or more than 1-channel not supported"};
  switch ( depth ) {
    case 0:
      img_depth_str = "8-bit unsigned ints (0..255)";
      break;
    case 1:
      img_depth_str = "8-bit signed ints (-128..127)";
      break;
    case 2:
      img_depth_str = "16-bit unsigned ints (0..65535)";
      break;
    case 3:
      img_depth_str = "16-bit signed ints (-32768..32767)";
      break;
    case 4:
      img_depth_str = "32-bit signed ints (-2147483648..2147483647)";
      break;
    case 5:
      img_depth_str = "32-bit floating-points (-FLT_MAX..FLT_MAX, INF, NAN)";
      break;
    case 6:
      img_depth_str = "64-bit floating-points (-DBL_MAX..DBL_MAX, INF, NAN)";
      break;
  }
  return img_depth_str;
}


/**
 * @brief Utilize the OpenCV optimal padding function.
 *
 * If either (or both) of the optimal rows or columns are odd, one row or column
 * is added to the padding. This must be done to ensure that the ideal filter/mask
 * rightmost column and bottommost row contain all zeros.
 *
 * @param image to pad
 * @param actual OUT padding values
 *
 * @return the padded image
 */
cv::Mat padImage( cv::Mat image, Padding &actual )
{
  cv::Mat padded;
  int optimalRows = cv::getOptimalDFTSize( image.rows );
  if (optimalRows % 2)  // odd
    optimalRows++;
  int optimalCols = cv::getOptimalDFTSize( image.cols );
  if (optimalCols % 2)  // odd
    optimalCols++;
  int pad_rows = optimalRows - image.rows;
  int pad_cols = optimalCols - image.cols;
  cv::copyMakeBorder( image, padded, 0, pad_rows, 0, pad_cols,
                      cv::BORDER_CONSTANT, cv::Scalar::all(255) );
  actual.top = 0;
  actual.bottom = pad_rows;
  actual.left = 0;
  actual.right = pad_cols;

  return padded;
}

/**
 * @brief Validate the sample rates not handled by CLI11.
 *
 * Rates cannot be equal to each other or less than zero.
 *
 * @param srcSampleRate source image
 * @param tgtSampleRate target image
 *
 * @throw NFIR::Miscue send appropriate message
 */
void validateUserSpecifiedSampleRates( int srcSampleRate, int tgtSampleRate )
{
  if( tgtSampleRate == srcSampleRate )
  {
    throw NFIR::Miscue( "NFIR lib: source and target sample rates cannot be equal" );
  }

  if( (srcSampleRate <= 0 ) || ( tgtSampleRate <= 0 ) )
  {
    throw NFIR::Miscue( "NFIR lib: src and/or target sample rate cannot be negative" );
  }
}
